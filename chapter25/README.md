# Algebra for monads
### Utilities used by code below
```ocaml
let compose f g x = f (g x)
let ( <.> ) = compose
module type Functor = sig
  type 'a t
  val fmap : ('a -> 'b) -> 'a t -> 'b t
end
module type MonadJoin = sig
  type 'a t
  include Functor with type 'a t := 'a t
  val join : 'a t t -> 'a t
  val return : 'a -> 'a t
end
module type Comonad = sig
  type 'a w
  include Functor with type 'a t := 'a w
  val extract : 'a w -> 'a
  val duplicate : 'a w -> 'a w w
end
```
### Introduction
- Endofunctors - defines expressions
- Algebras - Evaluate them
- Monads - Allows us to form and manipulate expressions
- Algebras + Monads
- Relation between monads and adjunctions
- Every adjunction defines a monad and a comonad
- Monad is an endofunctor m equipped with two natural transformations that satisfy some coherence conditions
- N_a : a -> m a
- U_a : m (m a) -> m a
- alg : m a -> a
- First coherence condition
  - alg compose N_a = id_a
- Second coherence condition
  - alg compose U_a = alg compose (m alg)
```OCaml
compose alg return = id
compose alg join = compose alg (fmap alg)
```
- Algebra for a list endofunctor
  - type a
  - function that produces a from [a]
- foldr can be used to express that algebra
```OCaml
val fold_right : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
```
- List Algebra - foldr f z 
```OCaml
(* List module in the OCaml standard library accepts list before z *)
List.fold_right f [x] z = f x z
```
- List Algebra is compatible with the monad if
```OCaml
f x z = x
```
- z is the right unit
### T-algebras
- T - Monads 
- Algebras compatible with monads - T algebras
- T algebras for a Monad T in category C form a Eilenberg-Moore category C^T
- Morphisms in that category are homomorphisms of algebras
- Forgetful functor U^T from C^T to C ; maps (a, f) -> a
  - Maps homomorphism of T algebras to a corresponding morphism between carrier objects in C
- Free functor(left adjoint to U^T) - F^T
  - maps an object a in C to C^T
- Left adjoint functor aka Free functor (F^T) - goes from C to C^T
- Right adjoint functor aka Forgetful functor (U^T) - goes from C^T to C
- F^T maps object a in C to an Object(Free algebra) in C^T. This object is T a
- morphisms in C^T are T (T a) -> T a
- To show that the Free algebra is a T algebra
  - compose alg (N_a at T a) = id at T a
  - compose alg U_a = compose alg (T alg)
- These are monadic laws
- Every adjunction defines a monad
- Adjunction between F^T and U^T also forms a monad and that monad is T.
- T was used to construct C^T
- Since we can form the category C^T for any monad and this category C^T forms a nice adjunction which leads to the formation of T monad, we can say that every monad can be formed from an adjunction
- Adjunction between F^T and U^T
  - To prove: F^T is the left adjoint of U^T
  - unit and counit for this adjunction
  - Triangular identities are satisfied
  - Monad generated by this adjunction is the original monad T
- unit of this adjunction
  - N :: I -> U^T `compose` F^T
  - Free functor -> Free algebra -> (T a, U_a)
  - Forgetful functor -> reduces the free algebra to T a
  - This is just a mapping from a to T a
  - unit of monad T provides this mapping
- counit of this adjunction
  - E :: F^T `compose` U^T -> I
  - T-algebra (a, f)
- Free algebra created bt F^T is (T a, U_a)
- Forgetful functor F^T drops the evaluator
  - U^T `compose` F^T = T
- counit of the adjunction produces monadic multiplication
  - U = R `compose` E `compose` L
### Kleisli Category
  - Kleisli category
  - Constructed from C and a monad T - C_T
  - Objects of C_T are objects of C but morphisms are different
  - f_K from a to b in C_T corresponds to a morphism f from a to T b in C
  - f_K is the kleisli arrow from a to b
  - Composition of morphisms in the Kleisli category is defined in terms of monadic composition of Kleisli arrows
  - In C_T
    - f_K : a -> b
    - g_K : b -> c
  - In C
    - f : a -> T b
    - g : b -> T c
  - Composition
    - h_K = g_K `compose` f_K
    - is a kleisli arrow in C
    - h : a -> T c
    - h = U `compose` T g `compose` f
```ocaml
module Kleisli_Composition(T : MonadJoin) = struct
  let h g f = T.join <.> T.fmap g <.> f
end
```
- Functor F from C to C_T
```OCaml
module C_to_CT(T : Monad) = struct
  let on_objects = T.return <.> f
end
```
- Functor G from C_T to C
  - on_objects : a -> T a
  - on_morphisms : f_K which corresponds to f : a -> T b in C
    - It produces a morphism T a -> T b in C
    - U at T b `compose` T f (Takes T a and produces T b)
- Two functors F and G form an adjunction
- G `compose` F forms the monad T
- THere is a whole category of adjunctions Adj(C, T) that result in monad T on C
- Kleisli adjunction is the initial object in this category
- EM adjunction is the terminal object in this category
### Coalgebras for Comonads
- coa : a -> W a
- E(extract) and D(duplicate) are the nat trans defining comonad.
### Lenses
- A lens can be written as a coalgebra
- coalg_s :: a -> ('s, 'a) store
```ocaml
type ('s, 'a) store = Store of ('s -> 'a) * 's
```
- Coalgebra as a pair of functions
  - set : 'a -> 's -> 'a
  - get : 'a -> 's
- coalg_s a = Store ((set a), (get a))
- Store is a comonad
```ocaml
module Store_comonad(S: sig type s end)(F : Functor with type 'a t = (S.s, 'a) store) : Comonad with type 'a w = (S.s, 'a) store = struct
  type 'a w = (S.s, 'a) store
  include F
  let extract : 'a w -> 'a = fun (Store (f, s)) -> f s
  let duplicate : 'a w -> ('a w) w = fun (Store (f, s)) -> Store ((fun s -> Store (f, s)), s)
end
```
- When is a lens a coalgebra?
```ocaml
module Store_Functor(S : sig type s end) : Functor with type 'a t = (S.s, 'a) store = struct
  type 'a w = (S.s, 'a) store
  type 'a t = 'a w
  
  let fmap g (Store (f, s)) = Store ((compose g f), s)
end
```
- coalg_s a = Store ((set a), (get a))
- fmap coalg to result of coalg
```OCaml
(* Assume <.> acts as compose *)
Store ((coalg_store <.> set a), (get a))
```
- Applying duplicate to result of coalg
```OCaml
Store ((fun s -> Store (set a, s)), (get a))
```
- Coalg must be equal to arbitrary s
```OCaml
(* Pseudo OCaml *)
let coalg_store (set a s) = Store ((set a), s)
```
- Expaning coalg
```OCaml
(* Expaning coalg_store *)
Store ((set (set a s)), (get (set a s))) = Store ((set a), s)
```
- Using the lens laws#1
```OCaml
set (set a s) = set a
```
- Using lens law#2
```OCaml
get (set a s) = s
```
- A well-behaved lens is a comonad coalgebra for the Store functor
